#!/bin/sh

# exit the installer if any command fails
set -e

# build-time settings (to be filled in by a build script)
version="__TARGET_VERSION__"


# check that the build process actually ran
tva=__TARGET
tvb=_VERSION__
if [ "$version" = "$tva$tvb" ]; then
  echo "No version set by the build process."
  exit
fi


# gather info about the local environment
here=$(pwd)


mkdirfs() #(path, chmod ops)
{
  if [ -d "$1" ]; then
    echo "Using exixting folder $1"
  else
    $fsdo mkdir -p "$1"
    if [ -n "$2" ]; then
      $fsdo chmod "$2" "$1"
    fi
    echo "Created folder $1"
  fi
}

mkdirswitch() #(path, chmod ops)
{
  if [ -d "$1" ]; then
    # make the folder as root, then change it to the service account
    mkdir -p "$1"
    chown "$username":"$groupname" "$1"
    if [ -n "$2" ]; then
      chmod "$2" "$1"
    fi
    echo "Created folder $1"
  else
    echo "Using exixting folder $1"
  fi
}


# determine what capabilities we have
whoami=$(whoami)
if [ "$whoami" = "root" ]; then

  echo "Installing in root mode: Will integrate with OS"
  oscaps="root"

  # determine filesystem capabilities
  testfile="$here/__fscaps_test__"
  if touch "$testfile" ; then
    # root user can write here
    rm "$testfile"
    # create files/folders as root
    fsdo=
    mkdirhere=mkdirswitch
  else
    # root user can't write here, so create files and folders as the service account instead
    fsdo="$usdo"
    mkdirhere=mkdirfs
    echo "Installing in root shared mode: Will create files/folders as service account"
  fi

  # get the username for the service account
  username=$PYP_USER
  if [ -z "$username" ]; then
    echo "No PYP_USER set."
    exit
  fi

  # get the groupname for the service account
  groupname=$PYP_GROUP
  if [ -z "$groupname" ]; then
    if getent group "$username"; then
      groupname=$username
    else
      echo "$username is not a valid group. Choose the pyp group by setting PYP_GROUP"
      exit
    fi
  fi

  echo "Installing nextPYP $version for service account $username in group $groupname ..."

  # make a way to do things as the service account, like sudo, but user-do
  usdo="sudo -u $username"

  # install binaries to the OS bin dir
  bindir=/usr/bin

  # get the home folder for the serivce account
  home=$(getent passwd "$username" | cut -d: -f6)

else

  echo "Installing in user mode: Will not integrate with OS"
  oscaps="user"

  username="$whoami"

  echo "Installing nextPYP $version as current account $username ..."

  usdo=
  fsdo=
  mkdirhere=mkdirfs

  # "install" binaries here
  bindir="$here"

  home="$HOME"
fi


if [ "$oscaps" = "root" ]; then
  # in root mode, save the installation folder somewhere canonical, so we can find it again later
  canondir="/opt/nextpyp"
  if [ "$here" = "$canondir" ]; then
    # as luck would have it, we're already installing into the canonical location
    true
  elif [ -L "$canondir" ]; then
    # already a symbolic link here, overwrite it
    ln -sf "$here" "$canondir"
  elif [ -e "$canondir" ]; then
    # something else installed here, panic!
    echo "Failed to create installdir symlink at $canondir, something else already exists there"
    exit 1
  else
    # nothing in canondir yet, create the link
    ln -s "$here" "$canondir"
  fi
fi


# configure downloads
www="https://nextpyp.app/files/pyp/$version"
wgetopts="-nv"
# for interactive use, it's helpful to turn on the progress bar to track long downloads
#wgetopts="$wgetopts --progress=bar"

download() #(path, chmod ops)
{
  $fsdo wget $wgetopts -O "$1" "$www/$1"
  if [ -n "$2" ]; then
    $fsdo chmod "$2" "$1"
  fi
}

# download the distribution files
echo "Downloading installation files from $www ..."
download "nextPYP.sif" ugo+r # container files need to be world-readable
download "pyp.sif" ugo+r
download "host-processor"
download "user-processor" u=rw,go=r
download "nextpyp"
download "uninstall"
download "install-rprox"

# NOTE: we don't make the local scripts (eg other installers/uninstallers) in $here executable
#       instead, the installation instructions ask the user to inspect them first
#       and then chmod +x later if satisfied


# download the workflow files
workflowDir="$here/workflows"
mkdirfs "$workflowDir" ugo+r
download "workflows/spr_tutorial.toml" ugo+r
download "workflows/tomo_tutorial.toml" ugo+r
download "workflows/class_tutorial.toml" ugo+r


install() #(filename, dest filename)
{
  if [ -n "$2" ]; then
    dstname="$2"
  else
    dstname="$1"
  fi
  # move the executables into the binaries dir (eg /usr/bin so SELinux won't deny access)
  outpath="$bindir/$dstname"
  if [ "$here/$1" != "$outpath" ]; then
  mv "$here/$1" "$outpath"
  fi
  chmod u=rwx,go=rx "$outpath"
}

# install executables
install "nextpyp"
install "host-processor" "nextpyp-host-processor"


# create initial folders and set up permissions

# make the base folders
localDir="$here/local"
$mkdirhere "$localDir" g+s
sharedDir="$here/shared"
$mkdirhere "$sharedDir" ugo+rx,g+s

# NOTE: The base folders have setgid (g+s) so all files inherit the service account group.
#       Setgid will propagate automatically to all subfolders when they're created,
#       so we don't need to re-set it for every folder.

# make the local sub-folders
mkdirfs "$localDir/logs"
mkdirfs "$localDir/db"
mkdirfs "$localDir/sock" ugo=rwx,+t

# make the shared sub-folders
mkdirfs "$sharedDir/batch" ugo=rwx,+t
mkdirfs "$sharedDir/log" ugo=rwx,+t
mkdirfs "$sharedDir/users" ugo=rwx,+t
mkdirfs "$sharedDir/user-processors" ugo=rwx,+t
mkdirfs "$sharedDir/sessions" # TODO: how should user-switching work for sessions?
mkdirfs "$sharedDir/groups"


# create the home configuration folder, if needed (apptainer needs it)
if [ "$oscaps" = "root" ]; then
  mkdirswitch "$home" u+rwx,go+rx,go-w
  mkdirswitch "$home/.config"
fi


# generate the initial configuration
configPath="$here/config.toml"
if [ -f "$configPath" ]; then
  echo "Using existing configuration file: $configPath"
else
  $fsdo cat << EOF > "$configPath"

[pyp]
# path to the PYP container file, from a SLURM compute node's point of view
container = '$here/pyp.sif'

# fast storage for temporary files, ideally local to the compute node
scratch = '/tmp/pyp'


[web]

# storage space for website files, database, etc
# for best performance, this should be on a filesystem local to the web server
localDir = '$localDir'

# storage space for files shared between the web server and the SLURM cluster
# this area should have a lot of available space for large files
sharedDir = '$sharedDir'

# directories for workflow files
workflowDirs = ['$workflowDir']

# authentication mode: how to log into the website
# disable authentication entirely in single-user mode
auth = "none"

EOF
  echo "Created configuration file: $configPath"
fi

# make sure others can't write to the config file
chmod o-w "$configPath"


if [ "$oscaps" = "root" ]; then
  echo "Installing integrations with systemd ..."

  # relevant documentation on systemd:
  # https://www.freedesktop.org/software/systemd/man/systemd.unit.html
  # https://www.freedesktop.org/software/systemd/man/systemd.exec.html
  # https://www.freedesktop.org/software/systemd/man/systemd.service.html


  # make the unit file for the application server
  appDaemon="nextPYP"
  appFile="/lib/systemd/system/$appDaemon.service"
  cat << EOF > "$appFile"
[Unit]
Description=$appDaemon

[Service]
Type=forking
Restart=always
RestartSec=1
User=$username
Environment=PYP_CONFIG=$configPath
ExecStart=$bindir/nextpyp start
ExecStop=$bindir/nextpyp stop

[Install]
WantedBy = multi-user.target
EOF
  chmod go-w "$appFile"


  # poke systemd to recognize the new daemons
  systemctl daemon-reload

  # start the demon now and at boot too
  systemctl start $appDaemon
  systemctl enable $appDaemon

else
  echo "WARNING: Since you did not run the installer as root, nextPYP will not start automatically"
  echo "To start manually, run: \"$here/nextpyp\" start"
  echo "To stop nextPYP, run: \"$here/nextpyp\" stop"
fi

echo "Finished installing nextPYP $version"
