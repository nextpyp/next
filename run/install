#!/bin/sh

# exit the installer if any command fails
set -e


# the installer should be run as root
if [ "$(whoami)" != "root" ]; then
  echo "This installer should be run as root"
  exit 1
fi


# build-time settings (to be filled in by a build script)
version="__TARGET_VERSION__"


# check that the build process actually ran
tva=__TARGET
tvb=_VERSION__
if [ "$version" = "$tva$tvb" ]; then
  echo "No version set by the build process."
  exit
fi


# gather info about the local environment
here=$(pwd)

# get the username
username=$PYP_USER
if [ -z "$username" ]; then
  echo "No PYP_USER set."
  exit
fi

# get the usergroup
usergroup=$PYP_GROUP
if [ -z "$usergroup" ]; then
  if getent group "$username"; then
    usergroup=$username
  else
    echo "$username is not a valid group. Choose the pyp group by setting PYP_GROUP"
    exit
  fi
fi

echo "Installing nextPYP $version for user $username ..."


# make a way to do things as the specified user
# user do, `usdo`, the complement of `sudo`
usdo="sudo -u $username"


# download the distribution files
echo "Downloading installation files ..."
www="https://nextpyp.app/files/pyp/$version"
wgetopts="-nv"
# for interactive use, it's helpful to turn on the progress bar to track long downloads
#wgetopts="$wgetopts --progress=bar"
$usdo wget $wgetopts -O "nextPYP.sif" "$www/nextPYP.sif"
$usdo wget $wgetopts -O "pyp.sif" "$www/pyp.sif"
$usdo wget $wgetopts -O "hostprocessor" "$www/hostprocessor"
$usdo wget $wgetopts -O "start" "$www/start"
$usdo wget $wgetopts -O "stop" "$www/stop"
$usdo wget $wgetopts -O "uninstall" "$www/uninstall"


# move the executables into /usr/bin (otherwise SELinux will deny access)
mv "$here/start" "/usr/bin/nextpyp-start"
chmod ugo+rx "/usr/bin/nextpyp-start"
mv "$here/stop" "/usr/bin/nextpyp-stop"
chmod ugo+rx "/usr/bin/nextpyp-stop"
mv "$here/hostprocessor" "/usr/bin/nextpyp-hostprocessor"
chmod ugo+rx "/usr/bin/nextpyp-hostprocessor"
mv "$here/uninstall" "/usr/bin/nextpyp-uninstall"
chmod ugo+rx "/usr/bin/nextpyp-uninstall"

# download the workflow files
workflowDir="$here/workflows"
workflowWww="$www/workflows"
$usdo mkdir -p "$workflowDir"
$usdo wget $wgetopts -O "$workflowDir/spr_tutorial.toml" "$workflowWww/spr_tutorial.toml"
$usdo wget $wgetopts -O "$workflowDir/tomo_tutorial.toml" "$workflowWww/tomo_tutorial.toml"
$usdo wget $wgetopts -O "$workflowDir/class_tutorial.toml" "$workflowWww/class_tutorial.toml"

# create initial directories
localDir="$here/local"
$usdo mkdir -p "$localDir"
$usdo chown "$username:$usergroup" "$localDir"
echo "Created local directory: $localDir"

sharedDir="$here/shared"
$usdo mkdir -p "$sharedDir"
$usdo chown "$username:$usergroup" "$sharedDir"
echo "Created shared directory: $sharedDir"

# create configuration file
$usdo mkdir -p "/home/$username/.config"
echo "Created /home/$username/.config directory"

# generate the initial configuration
configPath="$here/config.toml"
if [ -f "$configPath" ]; then
  echo "Using existing configuration file: $configPath"
else
  cat << EOF > "$configPath"

[pyp]
# path to the PYP container file, from a SLURM compute node's point of view
container = '$here/pyp.sif'

# fast storage for temporary files, ideally local to the compute node
scratch = '/tmp/pyp'


[web]

# storage space for website files, database, etc
# for best performance, this should be on a filesystem local to the web server
localDir = '$localDir'

# storage space for files shared between the web server and the SLURM cluster
# this area should have a lot of available space for large files
sharedDir = '$sharedDir'

# directories for workflow files
workflowDirs = ['$workflowDir']

EOF
  echo "Created configuration file: $configPath"
fi


echo "Installing integrations with systemd ..."

# relevant documentation on systemd:
# https://www.freedesktop.org/software/systemd/man/systemd.unit.html
# https://www.freedesktop.org/software/systemd/man/systemd.exec.html
# https://www.freedesktop.org/software/systemd/man/systemd.service.html


# make the unit file for the application server
appDaemon="nextPYP"
appFile="/lib/systemd/system/$appDaemon.service"
cat << EOF > "$appFile"
[Unit]
Description=$appDaemon

[Service]
Type=forking
Restart=always
RestartSec=1
WorkingDirectory=$here
User=$username
Environment=PYP_CONFIG=$configPath
ExecStart=/usr/bin/nextpyp-start
ExecStop=/usr/bin/nextpyp-stop

[Install]
WantedBy = multi-user.target
EOF
chmod go-w "$appFile"


# poke systemd to recognize the new daemons
systemctl daemon-reload

# start the demon now and at boot too
systemctl start $appDaemon
systemctl enable $appDaemon


echo "Finished installing nextPYP $version"
