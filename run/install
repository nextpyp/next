#!/bin/sh

# exit the installer if any command fails
set -e


# check for a testing override for the file download
if [ -n "$PYP_DIST" ]; then

  if [ ! -d "$PYP_DIST" ]; then
    echo "Folder not found: $PYP_DIST"
    exit 1
  fi

  version="testing"

else

  # release mode: download files from the public URL

  # build-time settings (to be filled in by a build script)
  version="__TARGET_VERSION__"


  # check that the build process actually ran
  tva=__TARGET
  tvb=_VERSION__
  if [ "$version" = "$tva$tvb" ]; then
    echo "No version set by the build process."
    exit 1
  fi
fi


# gather info about the local environment
here=$(pwd)


echo "Installing nextPYP $version at: $here"


# TODO: let admin know the old pyp container can be deleted


# look for an existing installation here and try to populate the original installation settings

# TODO: existing installations won't have these symlinks right? so need to add info to docs to make them
# first, get the folders based on symlinks
hereLocalDir="$here/local"
if [ -z "$PYP_LOCAL" ]; then
  if [ -L "$hereLocalDir" ]; then
    PYP_LOCAL="$(readlink "$hereLocalDir")"
    echo "Found previous local folder at: $PYP_LOCAL"
  elif [ -d "$hereLocalDir" ]; then
    echo "Found previous local folder at: $hereLocalDir"
  fi
fi

hereSharedDataDir="$here/shared"
if [ -z "$PYP_SHARED_DATA" ]; then
  if [ -L "$hereSharedDataDir" ]; then
    PYP_SHARED_DATA="$(readlink "$hereSharedDataDir")"
    echo "Found previous shared data folder at: $PYP_SHARED_DATA"
  elif [ -d "$hereSharedDataDir" ]; then
    echo "Found previous shared data folder at: $hereSharedDataDir"
  fi
fi

hereSharedExecDir="$here/sharedExec"
if [ -z "$PYP_SHARED_EXEC" ]; then
  if [ -L "$hereSharedExecDir" ]; then
    PYP_SHARED_EXEC="$(readlink "$hereSharedExecDir")"
    echo "Found previous shared exec folder at: $PYP_SHARED_EXEC"
  elif [ -d "$hereSharedExecDir" ]; then
    echo "Found previous shared exec folder at: $hereSharedExecDir"
  fi
fi

# then, try to get the user,group names from the folder
if [ -z "$PYP_USER" ] && [ -d "$hereSharedDataDir" ]; then
  PYP_USER="$(stat -c '%U' -L "$hereSharedDataDir")"
  echo "Found existing nextPYP account $PYP_USER"
fi
if [ -z "$PYP_GROUP" ] && [ -d "$hereSharedDataDir" ]; then
  PYP_GROUP="$(stat -c '%G' -L "$hereSharedDataDir")"
  echo "Found existing nextPYP group $PYP_GROUP"
fi


mkdirdo() { #(do, path, chmod ops)
  if [ -d "$2" ]; then
    echo "Using existing folder $2"
  else
    $1 mkdir -p "$2"
    if [ -n "$3" ]; then
      $1 chmod "$3" "$2"
    fi
    echo "Created folder $2"
  fi
}


# determine what capabilities we have
whoami=$(whoami)
if [ "$whoami" = "root" ]; then

  admin="$SUDO_USER"

  echo "Installing in root mode (admin=$admin): Will integrate with OS"
  oscaps="root"

  # get the username for the service account
  username=$PYP_USER
  if [ -z "$username" ]; then
    echo "No PYP_USER set."
    exit 1
  fi

  # get the groupname for the service account
  groupname=$PYP_GROUP
  if [ -z "$groupname" ]; then
    if getent group "$username" > /dev/null; then
      groupname=$username
    else
      echo "$username is not a valid group. Choose the pyp group by setting PYP_GROUP"
      exit 1
    fi
  fi

  echo "Installing for service account $username in group $groupname ..."

  # make a way to do things as the service account, like sudo, but service-do
  srvdo="sudo -u $username"

  # determine filesystem capabilities
  installOwner="$(stat -c '%U' "$here")"
  if [ "$installOwner" = "root" ]; then
    echo "Install folder owned by root"

    heredo=

  elif [ "$installOwner" = "$admin" ]; then
    echo "Install folder owned by administrator $admin"

    heredo="sudo -u $admin"

  elif [ "$installOwner" = "$username" ]; then
    echo "Install folder owned by service account"

    echo "ERROR: This installation mode is not recommended for security reasons."
    echo "       For installs as root, the service account should not have write access to the nextPYP executable files."
    echo "       Instead, install into a folder owned by root or an administrator account."
    exit 1

  else
    echo "Install folder owned by $installOwner"

    echo "ERROR: install folder $here should be owned by administrator $admin or root."
    exit 1

  fi

  mkdirheresrv() { #(path, chmod ops)

    if [ -d "$1" ]; then
      echo "Using existing folder $1"
    else

      # In a normal universe, we'd create the folder as the admin account and then chown to the service account.
      # But some networked filesystems won't allow chown, so we need to do something else:
      # like temporarily allowing the service account to write to the parent folder.

      # first, backup the parent folder permissions and allow write access to others
      parentdir=$(dirname "$1")
      backup=$(stat --format '%a' "$parentdir")
      $heredo chmod go+wx "$parentdir"

      # then, create the folder as the service account
      mkdirdo "$srvdo" "$1" "$2"

      # restore the original permissions
      $heredo chmod "$backup" "$parentdir"
    fi
  }

  mkdirherenotsrv() { #(path, chmod ops)
    # folder will be owned by root/admin, which is not the service account
    mkdirdo "$heredo" "$1" "$2"
  }

  # install binaries to the OS bin dir
  bindir=/usr/bin

  # get the home folder for the serivce account
  home=$(getent passwd "$username" | cut -d: -f6)

else

  echo "Installing in user mode: Will not integrate with OS"
  oscaps="user"

  username="$whoami"

  echo "Installing as current account $username ..."

  srvdo=
  heredo=
  mkdirheresrv() { #(path, chmod ops)
    mkdirdo "$srvdo" "$1" "$2"
  }
  mkdirherenotsrv() { #(path, chmod ops)
    # not possible to have folders owned by another user, so just use this one and hope for the best
    mkdirdo "$srvdo" "$1" "$2"
  }

  # "install" binaries here
  bindir="$here"

  home="$HOME"
fi


if [ "$oscaps" = "root" ]; then

  # in root mode, save the installation folder somewhere canonical, so we can find it again later
  canondir="/opt/nextpyp"
  if [ "$here" = "$canondir" ]; then
    # as luck would have it, we're already installing into the canonical location
    true
  elif [ -L "$canondir" ]; then
    # already a symbolic link here, overwrite it
    rm "$canondir"
    ln -s "$here" "$canondir"
  elif [ -e "$canondir" ]; then
    # something else installed here, panic!
    echo "Failed to create installdir symlink at $canondir, something else already exists there"
    exit 1
  else
    # nothing in canondir yet, create the link
    ln -s "$here" "$canondir"
  fi
fi


# create initial folders and set up permissions

# make the local folder, or use the one given
if [ -n "$PYP_LOCAL" ]; then

  # check existence
  if [ ! -d "$PYP_LOCAL" ]; then
    echo "ERROR: Local folder given by PYP_LOCAL not found"
    echo "       PYP_LOCAL=$PYP_LOCAL"
    exit 1
  fi

  # check ownership
  localOwner="$(stat -c '%U' "$PYP_LOCAL")"
  if [ "$localOwner" != "$username" ]; then
    echo "ERROR: Local folder given by PYP_LOCAL should be owned by service account $username"
    echo "       Instead it's owned by $localOwner"
    echo "       PYP_LOCAL=$PYP_LOCAL"
    exit 1
  fi

  localDir="$PYP_LOCAL"

  # make a symlink to the local folder in the install dir so scripts can easily find it again later
  if [ -L "$hereLocalDir" ]; then
    $heredo rm "$hereLocalDir"
  fi
  $heredo ln -s "$localDir" "$hereLocalDir"

else

  # no folder given, use a folder inside the installation folder
  localDir="$hereLocalDir"
  mkdirheresrv "$localDir" g+s

  # check ownership
  localOwner="$(stat -c '%U' "$localDir")"
  if [ "$localOwner" != "$username" ]; then
    echo "ERROR: Local folder should be owned by service account $username"
    echo "       Instead it's owned by $localOwner"
    echo "       Path: $localDir"
    exit 1
  fi
fi


# make the shared data folder, or use the one given
if [ -n "$PYP_SHARED_DATA" ]; then

  # check existence
  if [ ! -d "$PYP_SHARED_DATA" ]; then
    echo "ERROR: Shared folder given by PYP_SHARED_DATA not found"
    echo "       PYP_SHARED_DATA=$PYP_SHARED_DATA"
    exit 1
  fi

  # check ownership
  sharedOwner="$(stat -c '%U' "$PYP_SHARED_DATA")"
  if [ "$sharedOwner" != "$username" ]; then
    echo "ERROR: Shared folder given by PYP_SHARED_DATA should be owned by service account $username"
    echo "       Instead it's owned by $sharedOwner"
    echo "       PYP_SHARED_DATA=$PYP_SHARED_DATA"
    exit 1
  fi

  sharedDataDir="$PYP_SHARED_DATA"

  # make a symlink to the shared folder in the install dir so scripts can easily find it again later
  if [ -L "$hereSharedDataDir" ]; then
    $heredo rm "$hereSharedDataDir"
  fi
  $heredo ln -s "$sharedDataDir" "$hereSharedDataDir"

else

  # no folder given, use a folder inside the installation folder
  sharedDataDir="$hereSharedDataDir"
  mkdirheresrv "$sharedDataDir" ugo+rx,g+s

  # check ownership
  sharedOwner="$(stat -c '%U' "$sharedDataDir")"
  if [ "$localOwner" != "$username" ]; then
    echo "ERROR: Shared data folder should be owned by service account $username"
    echo "       Instead it's owned by $sharedOwner"
    echo "       Path: $sharedDataDir"
    exit 1
  fi
fi


# make the shared exec folder, or use the one given
if [ -n "$PYP_SHARED_EXEC" ]; then

  # check existence
  if [ ! -d "$PYP_SHARED_EXEC" ]; then
    echo "ERROR: Shared exec folder given by PYP_SHARED_EXEC not found"
    echo "       PYP_SHARED_EXEC=$PYP_SHARED_EXEC"
    exit 1
  fi

  # check ownership, if useful (can't enforce admin ownership when there's no admin, ie in unprivileged user mode)
  if [ "$oscaps" = "root" ]; then
    sharedExecOwner="$(stat -c '%U' "$PYP_SHARED_EXEC")"
    if [ "$sharedExecOwner" != "root" ] && [ "$sharedExecOwner" != "$admin" ]; then
      echo "ERROR: Shared exec folder given by PYP_SHARED_EXEC should be owned by root or $admin"
      echo "       Instead, it is owned by $sharedExecOwner"
      echo "       PYP_SHARED_EXEC=$PYP_SHARED_EXEC"
      exit 1
    fi
  fi

  sharedExecDir="$PYP_SHARED_EXEC"

  sharedexecdo="sudo -u $admin"

  # make a symlink to the shared exec folder in the install dir so scripts can easily find it again later
  if [ -L "$hereSharedExecDir" ]; then
    $heredo rm "$hereSharedExecDir"
  fi
  $heredo ln -s "$sharedExecDir" "$hereSharedExecDir"

else

  # no folder given, use a folder in the installation folder
  sharedExecDir="$hereSharedExecDir"
  mkdirherenotsrv "$sharedExecDir" ugo+rx,g+s

  # check ownership, if useful (can't enforce admin ownership when there's no admin, ie in unprivileged user mode)
  if [ "$oscaps" = "root" ]; then
    sharedExecOwner="$(stat -c '%U' "$sharedExecDir")"
    if [ "$sharedExecOwner" != "root" ] && [ "$sharedExecOwner" != "$admin" ]; then
      echo "ERROR: Shared exec folder should be owned by root or $admin"
      echo "       Instead, it is owned by $sharedExecOwner"
      echo "       Path: $sharedExecDir"
      exit 1
    fi
  fi

  sharedexecdo=$heredo
fi


# NOTE: The base folders have setgid (g+s) so all files inherit the service account group.
#       Setgid will propagate automatically to all subfolders when they're created,
#       so we don't need to re-set it for every folder.

# make the local sub-folders
mkdirdo "$srvdo" "$localDir/containers"
mkdirdo "$srvdo" "$localDir/logs"
mkdirdo "$srvdo" "$localDir/db"
mkdirdo "$srvdo" "$localDir/sock" ugo=rwx,+t

# make the shared sub-folders
mkdirdo "$srvdo" "$sharedDataDir/batch" ugo=rwx,+t
mkdirdo "$srvdo" "$sharedDataDir/log" ugo=rwx,+t
mkdirdo "$srvdo" "$sharedDataDir/users"
mkdirdo "$srvdo" "$sharedDataDir/os-users" ugo=rwx,+t
mkdirdo "$srvdo" "$sharedDataDir/sessions"
mkdirdo "$srvdo" "$sharedDataDir/groups"

# The user-processors folder needs some special case, since it houses set-uid executables:
# The folder should be owned by the service account, and the service group.
# But we need to explicitly set the service group for this folder, since the group might
# be something other than the service group chosen in this installer by default,
# ie, the parent folder's group, or the service account's default group.
# And it is *vitally* important the user-processors folder have the tmpdir bit set,
# so the service account can't overwrite the users' executables.
userProcessorsDir="$sharedDataDir/user-processors"
mkdirdo "$srvdo" "$userProcessorsDir" ugo=rwx,+t
$srvdo chown ":$groupname" "$userProcessorsDir"

# make the shared exec sub-folders
mkdirdo "$sharedexecdo" "$sharedExecDir/containers"


# configure downloads
www="https://nextpyp.app/files/pyp/$version"
wgetopts="-nv"
# for interactive use, it's helpful to turn on the progress bar to track long downloads
#wgetopts="$wgetopts --progress=bar"

download() { #(do, path, todir, chmod vops)
  if [ -n "$PYP_DIST" ]; then
    # copy distribution files from the local path
    echo "Copying $3/$2 ..."
    $1 cp "$PYP_DIST/$2" "$3/$2"
  else
    # otherwise, download from the URL
    $1 wget $wgetopts -O "$3/$2" "$www/$2"
  fi
  $1 chmod "$4" "$3/$2"
}

# download the distribution files
if [ -n "$PYP_DIST" ]; then
  echo "Copying installation files from $PYP_DIST ..."
else
  echo "Downloading installation files from $www ..."
fi

download "$heredo" "nextPYP.sif" "$here" u=rw,go=r
download "$heredo" "host-processor" "$here" u=rw,go=r
download "$heredo" "user-processor" "$here" u=rw,go=r
download "$heredo" "nextpyp" "$here" u=rw,go=r
download "$heredo" "uninstall" "$here" u=rw,go=r
download "$heredo" "install-rprox" "$here" u=rw,go=r

# NOTE: we don't make the local scripts (eg other installers/uninstallers) in $here executable
#       instead, the installation instructions ask the user to inspect them first
#       and then chmod +x later if satisfied


# download shared containers into the shared exec folder
download_container() { #(name)
  download "$sharedexecdo" "$1" "$sharedExecDir/containers" u=rw,go=r # shared container files need to be world-readable
}
download_container "pyp.sif"


# download the workflow files
workflowDir="$here/workflows"
mkdirdo "$heredo" "$workflowDir" u=rwx,go=r
download "$heredo" "workflows/spr_tutorial.toml" "$here" u=rw,go=r
download "$heredo" "workflows/tomo_tutorial.toml" "$here" u=rw,go=r
download "$heredo" "workflows/class_tutorial.toml" "$here" u=rw,go=r


install() { #(filename, dest filename)
  if [ -n "$2" ]; then
    dstname="$2"
  else
    dstname="$1"
  fi
  # move the executables into the binaries dir (eg /usr/bin so SELinux won't deny access)
  outpath="$bindir/$dstname"
  if [ "$here/$1" != "$outpath" ]; then
    cp -f "$here/$1" "$outpath"
    $heredo rm "$here/$1"
  fi
  chmod u=rwx,go=rx "$outpath"
}

# install executables
install "nextpyp"
install "host-processor" "nextpyp-host-processor"


# create the home configuration folder, if needed (apptainer needs it)
if [ "$oscaps" = "root" ]; then
  if [ ! -d "$home" ]; then
    echo "Service account has no home folder, attempting to create automatically ..."
    echo "If automatic home folder creation fails, create the home folder manually and try installing again."
    mkdirdo "" "$home" u+rwx,go+rx,go-w
    chown "$username:$groupname" "$home"
  else
    echo "Home folder for service account already exists: $home"
  fi
  mkdirdo "$srvdo" "$home/.config" u+rwx,go+rx,go-w
fi


hereConfigPath="$here/config.toml"
configPath="$sharedExecDir/config.toml"

# if a config file exists in the old location, move it to the new one
if [ -f "$hereConfigPath" ] && [ ! -L "$hereConfigPath" ]; then
  echo "Found config file in old location: $hereConfigPath"
  $sharedexecdo mv "$hereConfigPath" "$configPath"
  $heredo ln -s "$configPath" "$hereConfigPath"
  echo "Moved config file to new location: $configPath"
fi

# generate the initial configuration, if needed
if [ -f "$configPath" ]; then
  echo "Using existing configuration file: $configPath"
else
  $sharedexecdo tee "$configPath" > /dev/null << EOF

[pyp]

# fast storage for temporary files, ideally local to the compute node
scratch = '/tmp/pyp'

# add folder paths into this list to make your data visible to nextPYP
binds = []


[web]

# Storage space for website files, database, etc.
# For best performance, this should be on a filesystem local to the web server.
localDir = '$localDir'

# Storage space for files shared between the web server and the data processing jobs.
# This area should have a lot of available space for large files
# and should be writable by the account running nextpyp.
sharedDir = '$sharedDataDir'

# Storage space for the executables needed by data processing jobs,
# and the and configuration (like this file) shared between the web server and the data processing jobs.
# This area should be read-only to the account running nextpyp.
sharedExecDir = '$sharedExecDir'

# directories for workflow files
workflowDirs = ['$workflowDir']

# authentication mode: how to log into the website
# disable authentication entirely in single-user mode
auth = "none"

EOF
  echo "Created configuration file: $configPath"
  $heredo ln -s "$configPath" "$hereConfigPath"
fi

# make sure others can't write to the config file
$sharedexecdo chmod ug=rw,o=r "$configPath"

if [ "$oscaps" = "root" ]; then
  echo "Installing integrations with systemd ..."

  # relevant documentation on systemd:
  # https://www.freedesktop.org/software/systemd/man/systemd.unit.html
  # https://www.freedesktop.org/software/systemd/man/systemd.exec.html
  # https://www.freedesktop.org/software/systemd/man/systemd.service.html


  # make the unit file for the application server
  appDaemon="nextPYP"
  appFile="/lib/systemd/system/$appDaemon.service"
  tee "$appFile" > /dev/null << EOF
[Unit]
Description=$appDaemon

[Service]
Type=forking
Restart=always
RestartSec=1
User=$username
ExecStart=$bindir/nextpyp start
ExecStop=$bindir/nextpyp stop

[Install]
WantedBy = multi-user.target
EOF
  chmod go-w "$appFile"


  # poke systemd to recognize the new daemon
  systemctl daemon-reload

  # (try to) start the demon now
  if ! systemctl start $appDaemon; then
    echo "ERROR: Looks like nextPYP failed to start the first time."
    echo "       The first place to look for information is the systemd logs."
    echo "       You can do that with \`sudo journalctl -ue nextPYP\`"
    echo "       If there's no useful information there, the next place to look is the init log:"
    echo "       \`cat "$localDir/logs/init.log"\`"
    echo "       If there's no useful in formation there, the next place to look is the supervisord log:"
    echo "       \`cat "$localDir/logs/superd"\`"
    echo "       Finally, the last place to look for error information is the website log:"
    echo "       \`tail -n 200 "$localDir/logs/micromon"\`"
    echo "       If any of the above log files are missing, it means nextPYP never reached that stage of the startup procedure."
    exit 1
  fi

  # and at boot too
  systemctl enable $appDaemon

  # seems to be running ok, show the status
  systemctl --no-pager --full status $appDaemon

else
  echo "NOTE: Since you did not run the installer as root, nextPYP will not start automatically"
  echo "      To start manually, run: \"$here/nextpyp\" start"
  echo "      To stop nextPYP, run: \"$here/nextpyp\" stop"
fi

echo "Finished installing nextPYP $version"
