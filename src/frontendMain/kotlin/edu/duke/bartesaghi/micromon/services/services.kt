package edu.duke.bartesaghi.micromon.services

import io.kvision.remote.ServiceException
import kotlinx.coroutines.await
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.json.Json
import org.w3c.xhr.XMLHttpRequest
import kotlin.js.Promise


object Services {

	// these classes don't exist in the source code
	// they're automatically generated by KVision

	val admin = AdminService()
	val projects = ProjectsService()
	val forms = FormService()
	val blocks = BlocksService()
	val sessions = SessionsService()
	val singleParticleSessions = SingleParticleSessionService()
	val tomographySessions = TomographySessionService()
	val jobs = JobsService()
	val particles = ParticlesService()
	val apps = AppsService()

	// nodes
	val singleParticleRawData = SingleParticleRawDataService()
	val singleParticleRelionData = SingleParticleRelionDataService()
	val singleParticleImportData = SingleParticleImportDataService()
	val singleParticleSessionData = SingleParticleSessionDataService()
	val singleParticlePreprocessing = SingleParticlePreprocessingService()
	val singleParticlePurePreprocessing = SingleParticlePurePreprocessingService()
	val singleParticleDenoising = SingleParticleDenoisingService()
	val singleParticlePicking = SingleParticlePickingService()
	val singleParticleDrgn = SingleParticleDrgnService()
	val integratedRefinement = IntegratedRefinementService()
	val singleParticleCoarseRefinement = SingleParticleCoarseRefinementService()
	val singleParticleFineRefinement = SingleParticleFineRefinementService()
	val singleParticleFlexibleRefinement = SingleParticleFlexibleRefinementService()
	val singleParticlePostprocessing = SingleParticlePostprocessingService()
	val singleParticleMasking = SingleParticleMaskingService()
	val tomographyRawData = TomographyRawDataService()
	val tomographyRelionData = TomographyRelionDataService()
	val tomographyImportData = TomographyImportDataService()
	val tomographySessionData = TomographySessionDataService()
	val tomographyPreprocessing = TomographyPreprocessingService()
	val tomographyPurePreprocessing = TomographyPurePreprocessingService()
	val tomographyDenoising = TomographyDenoisingService()
	val tomographyDenoisingTraining = TomographyDenoisingTrainingService()
	val tomographyDenoisingEval = TomographyDenoisingEvalService()
	val tomographyPicking = TomographyPickingService()
	val tomographySegmentationOpen = TomographySegmentationOpenService()
	val tomographySegmentationClosed = TomographySegmentationClosedService()
	val tomographyPickingOpen = TomographyPickingOpenService()
	val tomographyPickingClosed = TomographyPickingClosedService()
	val tomographyMiloEval = TomographyMiloEvalService()
	val tomographyMiloTrain = TomographyMiloTrainService()
	val tomographyParticlesTrain = TomographyParticlesTrainService()
	val tomographyParticlesEval = TomographyParticlesEvalService()
	val tomographyDrgn = TomographyDrgnService()
	val tomographyCoarseRefinement = TomographyCoarseRefinementService()
	val tomographyFineRefinement = TomographyFineRefinementService()
	val tomographyMovieCleaning = TomographyMovieCleaningService()
	val tomographyFlexibleRefinement = TomographyFlexibleRefinementService()


	/**
	 * Use the raw XMLHttpRequest API to talk to the server.
	 * This should be the fastest kind of transfer we can get.
	 */
	object Raw {

		private fun String.orBlank(): String =
			takeIf { it.isNotBlank() }
				?: "(no error message received)"

		suspend fun getString(url: String): String =
			Promise<String> { resolve, reject ->

				XMLHttpRequest().apply {

					open("GET", url, true)

					onload = {
						when (status.toInt()) {
							200 -> resolve(responseText)
							400 -> reject(ServiceException(responseText))
							else -> reject(RuntimeException("HTTP GET failed: $status $statusText\n${responseText.orBlank()}"))
						}
					}

					onerror = {
						reject(RuntimeException("HTTP GET failed with an unspecified error. Check the browser console for more information"))
					}
					ontimeout = {
						reject(RuntimeException("HTTP GET timeout"))
					}

					send()
				}
			}.await()

		suspend inline fun <reified T> get(url: String): T =
			Json.decodeFromString(getString(url))

		suspend fun postString(url: String, body: String): String =
			Promise<String> { resolve, reject ->

				XMLHttpRequest().apply {

					open("POST", url, true)

					onload = {
						when (status.toInt()) {
							200 -> resolve(responseText)
							400 -> reject(ServiceException(responseText))
							else -> reject(RuntimeException("HTTP POST failed: $status $statusText\n${responseText.orBlank()}"))
						}
					}

					onerror = {
						reject(RuntimeException("HTTP POST failed with an unspecified error. Check the browser console for more information"))
					}
					ontimeout = {
						reject(RuntimeException("HTTP POST timeout"))
					}

					setRequestHeader("Content-type", "text/plain")
					send(body)
				}
			}.await()

		suspend inline fun <reified T> post(url: String, body: String): T =
			Json.decodeFromString(postString(url, body))
	}
}

suspend fun JobsService.getMicrographs(jobId: String): List<MicrographMetadata> =
	Services.Raw.get("/kv/jobs/$jobId/micrographs")

suspend fun JobsService.getTiltSerieses(jobId: String): List<TiltSeriesData> =
	Services.Raw.get("/kv/jobs/$jobId/tiltSerieses")

suspend fun FormService.fileBrowserFolderFast(path: String): FileBrowserFolder =
	Services.Raw.post("/kv/form/fileBrowserFolderFast", path)

suspend fun ParticlesService.getParticles2D(ownerType: OwnerType, ownerId: String, name: String, datumId: String): Particles2DData =
	Services.Raw.post("/kv/particles/${ownerType.id}/$ownerId/$datumId/getParticles2D", name)

suspend fun ParticlesService.getParticles3D(ownerType: OwnerType, ownerId: String, name: String, datumId: String): Particles3DData =
	Services.Raw.post("/kv/particles/${ownerType.id}/$ownerId/$datumId/getParticles3D", name)
